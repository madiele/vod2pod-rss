use std::collections::BTreeMap;
use std::fmt::Display;
use std::time::Duration;

use eyre::eyre;
use log::debug;
use reqwest::Url;
use rss::Channel;
use rss::{Enclosure, Item};

use crate::configs::{conf, AudioCodec, Conf, ConfName};

pub fn inject_vod2pod_customizations(
    rss_body: String,
    transcode_service_url: Option<Url>,
) -> eyre::Result<String> {
    let mut injected_feed = Channel::read_from(rss_body.as_bytes())?;
    injected_feed.set_generator(Some("generated by vod2pod-rss".to_string()));
    let mut namespaces = BTreeMap::new();
    namespaces.insert(
        "rss".to_string(),
        "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string(),
    );
    namespaces.insert(
        "itunes".to_string(),
        "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string(),
    );
    injected_feed.set_namespaces(namespaces);
    injected_feed
        .items_mut()
        .iter_mut()
        .try_for_each(|item| -> eyre::Result<_> {
            let description = get_description(item);
            item.set_description(description);
            let bitrate: u64 = conf()
                .get(ConfName::Mp3Bitrate)
                .unwrap()
                .parse()
                .expect("MP3_BITRATE must be a number");
            let generation_uuid = uuid::Uuid::new_v4().to_string();
            let codec: AudioCodec = conf().get(ConfName::AudioCodec).unwrap().into();
            let ext = format!(".{}", codec.get_extension_str());
            if let Some(mut transcode_service_url) = transcode_service_url.clone() {
                let duration_secs = &item
                    .itunes_ext()
                    .and_then(|i| Some(parse_duration(i.duration()?).ok()?.as_secs()))
                    .ok_or(eyre!(
                        "no duration found or could not parse {:?}",
                        item.itunes_ext()
                    ))?;
                transcode_service_url
                    .query_pairs_mut()
                    .append_pair("bitrate", bitrate.to_string().as_str())
                    .append_pair("uuid", generation_uuid.as_str())
                    .append_pair("duration", duration_secs.to_string().as_str())
                    .append_pair("url", item.link().ok_or(eyre!("not url found in item"))?)
                    .append_pair("ext", ext.as_str()); //this should allways be last, some players refuse to play urls not ending in .mp3

                let enclosure = Enclosure {
                    length: (bitrate * 1024 * duration_secs).to_string(),
                    url: transcode_service_url.to_string(),
                    mime_type: "audio/mpeg".to_string(),
                };

                debug!(
                    "setting enclosure to: \nlength: {}, url: {}, mime_type: {}",
                    enclosure.length, enclosure.url, enclosure.mime_type
                );
                item.set_enclosure(Some(enclosure));
            }
            Ok(())
        })?;

    Ok(injected_feed.to_string())
}

#[derive(Clone, Hash)]
struct TranscodeParams {
    transcode_service_url_str: String,
    feed_url: Url,
    should_transcode: bool,
}

impl Display for TranscodeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}_{}", &self.transcode_service_url_str, &self.feed_url)
    }
}

fn get_description(item: &Item) -> String {
    const FOOTER: &str = concat!(
        "<br><br>generated by vod2pod-rss ",
        env!("CARGO_PKG_VERSION"),
        " made by Mattia Di Eleuterio (<a href=\"https://github.com/madiele\">madiele</a>). Check out the <a href=\"https://github.com/madiele/vod2pod-rss\">GitHub repository</a>."
    );
    let description = item.description().unwrap_or_default();
    let url = item.link().unwrap_or_default();
    let img = item
        .itunes_ext()
        .and_then(|i| i.image())
        .unwrap_or_default();

    let original_link = format!(
        "<br><br><a href=\"{}\"><p>link to original</p><img src=\"{}\"></a>",
        url, img
    );
    format!("{}{}{}", description, original_link, FOOTER)
}

fn parse_duration(duration_str: &str) -> Result<Duration, String> {
    let duration_parts: Vec<&str> = duration_str.split(':').rev().collect();

    let seconds = match duration_parts.first() {
        Some(sec_str) => sec_str.parse().map_err(|_| "Invalid format".to_string())?,
        None => 0,
    };

    let minutes = match duration_parts.get(1) {
        Some(min_str) => min_str.parse().map_err(|_| "Invalid format".to_string())?,
        None => 0,
    };

    let hours = match duration_parts.get(2) {
        Some(hour_str) => hour_str.parse().map_err(|_| "Invalid format".to_string())?,
        None => 0,
    };

    let duration_secs = hours * 3600 + minutes * 60 + seconds;
    Ok(Duration::from_secs(duration_secs))
}

